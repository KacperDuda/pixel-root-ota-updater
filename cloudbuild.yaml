steps:
  # 0. Sprawdź dostępność Artifact Registry
  # Ten krok zapobiega uruchomieniu builda, jeśli repozytorium nie istnieje.
  - name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "Verifying Artifact Registry existence: ${_DOCKER_REPO_URL}"
        # Próbujemy wylistować obrazy (nawet pusta lista oznacza sukces = repo istnieje)
        if ! gcloud artifacts docker images list ${_DOCKER_REPO_URL} --limit=1 > /dev/null 2>&1; then
          echo "ERROR: Artifact Registry repository '${_DOCKER_REPO_URL}' does not exist or is not accessible."
          echo "Please ensure the Terraform infrastructure has been applied successfully."
          exit 1
        fi
        echo "Artifact Registry verified successfully."
  # 1. Pobierz ("Wypożycz") klucz z Secret Managera
  # To zapewnia, że klucz istnieje. Jeśli nie (błąd 404/403), build tutaj PADNIE i nie uruchomi kontenera.
  # Klucz trafia do wolumenu /workspace, który jest współdzielony i ulotny (znika po buildzie).
  - name: 'gcr.io/cloud-builders/gcloud'
    args:
      - 'secrets'
      - 'versions'
      - 'access'
      - 'latest'
      - '--secret=avb-private-key'
      - '--out-file=cyber_rsa4096_private.pem'

      - '--out-file=cyber_rsa4096_private.pem'

  # 1b. Spróbuj pobrać poprzedni obraz (dla Cache'a)
  # "|| exit 0" zapewnia, że błąd (np. brak obrazu przy pierwszym uruchomieniu) nie przerwie builda.
  - name: 'gcr.io/cloud-builders/docker'
    entrypoint: 'bash'
    args: ['-c', 'docker pull ${_DOCKER_REPO_URL}/pixel-automator:latest || exit 0']

  # 2. Zbuduj obraz (Docker) z wykorzystaniem Cache'a
  - name: 'gcr.io/cloud-builders/docker'
    args: [
      'build',
      '-t', '${_DOCKER_REPO_URL}/pixel-automator:latest',
      '--cache-from', '${_DOCKER_REPO_URL}/pixel-automator:latest',
      '.'
    ]

  # 3. Zaktualizuj Cloud Run Job (nowym obrazem)
  - name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "Updating Cloud Run Job: ${_REPO_NAME}-job with image: ${_DOCKER_REPO_URL}/pixel-automator:latest"
        gcloud run jobs update ${_REPO_NAME}-job \
          --image ${_DOCKER_REPO_URL}/pixel-automator:latest \
          --region ${_REGION} \
          --set-env-vars=_DEVICE_CODENAME=${_DEVICE_CODENAME} \
          --set-env-vars=_BUCKET_NAME=${_BUCKET_NAME} \
          --set-env-vars=CACHE_BUCKET_NAME=${_CACHE_BUCKET_NAME}

  # 4. Uruchom Joba (Test poprawności po wdrożeniu)
  # Opcjonalnie: można to pominąć i polegać na Schedulerze, ale warto sprawdzić czy działa od razu.
  - name: 'gcr.io/cloud-builders/gcloud'
    args: ['run', 'jobs', 'execute', '${_REPO_NAME}-job', '--region', '${_REGION}', '--wait']

  # 5. Deploy Web Flasher
  - name: 'gcr.io/cloud-builders/gsutil'
    args: ['rsync', '-r', 'web', 'gs://${_WEB_BUCKET_NAME}']



images:
  - '${_DOCKER_REPO_URL}/pixel-automator:latest'

substitutions:
  _DEVICE_CODENAME: 'frankel'
  _BUCKET_NAME: ''      # Must be provided by the Trigger
  _CACHE_BUCKET_NAME: '' # Must be provided by the Trigger
  _WEB_BUCKET_NAME: ''   # Must be provided by the Trigger

timeout: '3600s' 
options:
  machineType: 'E2_HIGHCPU_8'
  logging: CLOUD_LOGGING_ONLY